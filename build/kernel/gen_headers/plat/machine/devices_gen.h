/*
 * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
 *
 * SPDX-License-Identifier: GPL-2.0-only
 */

/*
 * This file is autogenerated by <kernel>/tools/hardware/outputs/c_header.py.
 */

#pragma once

#define PHYS_BASE_RAW 0x1000000

#ifndef __ASSEMBLER__

#include <config.h>
#include <mode/hardware.h>  /* for KDEV_BASE */
#include <linker.h>         /* for BOOT_RODATA */
#include <basic_types.h>    /* for p_region_t, kernel_frame_t (arch/types.h) */

/* Wrap raw physBase location constant to give it a symbolic name in C that's
 * visible to verification. This is necessary as there are no real constants
 * in C except enums, and enums constants must fit in an int.
 */
static inline CONST word_t physBase(void)
{
    return PHYS_BASE_RAW;
}

/* INTERRUPTS */
/* INTERRUPT_VGIC_MAINTENANCE generated from /soc/interrupt-controller@c4301000 */
#define INTERRUPT_VGIC_MAINTENANCE 25
/* INTERRUPT_VTIMER_EVENT generated from /timer */
#define INTERRUPT_VTIMER_EVENT 27
/* KERNEL_TIMER_IRQ generated from /timer */
#ifdef CONFIG_ARM_HYPERVISOR_SUPPORT
#define KERNEL_TIMER_IRQ 26
#else
#define KERNEL_TIMER_IRQ 27
#endif /* CONFIG_ARM_HYPERVISOR_SUPPORT */
/* KERNEL_UART_IRQ generated from /soc/bus@c8100000/serial@4c0 */
#define KERNEL_UART_IRQ 225
/* KERNEL DEVICES */
#define UART_PPTR (KDEV_BASE + 0x4c0)
#define GIC_V2_DISTRIBUTOR_PPTR (KDEV_BASE + 0x1000)
#define GIC_V2_CONTROLLER_PPTR (KDEV_BASE + 0x2000)
#define GIC_V2_VCPUCTRL_PPTR (KDEV_BASE + 0x3000)
#define WDOG_PPTR (KDEV_BASE + 0x48d0)

static const kernel_frame_t BOOT_RODATA kernel_device_frames[] = {
    /* /soc/bus@c8100000/serial@4c0 */
    {
        .paddr = 0xc8100000,
        /* contains UART_PPTR */
        .pptr = KDEV_BASE + 0x0,
        .armExecuteNever = true,
        .userAvailable = true
    },
    /* /soc/interrupt-controller@c4301000 */
    {
        .paddr = 0xc4301000,
        .pptr = GIC_V2_DISTRIBUTOR_PPTR,
        .armExecuteNever = true,
        .userAvailable = false
    },
    /* /soc/interrupt-controller@c4301000 */
    {
        .paddr = 0xc4302000,
        .pptr = GIC_V2_CONTROLLER_PPTR,
        .armExecuteNever = true,
        .userAvailable = false
    },
    #ifdef CONFIG_ARM_HYPERVISOR_SUPPORT
    /* /soc/interrupt-controller@c4301000 */
    {
        .paddr = 0xc4304000,
        .pptr = GIC_V2_VCPUCTRL_PPTR,
        .armExecuteNever = true,
        .userAvailable = false
    },
    #endif /* CONFIG_ARM_HYPERVISOR_SUPPORT */
    /* /soc/bus@c1100000/watchdog@98d0 */
    {
        .paddr = 0xc1109000,
        /* contains WDOG_PPTR */
        .pptr = KDEV_BASE + 0x4000,
        .armExecuteNever = true,
        .userAvailable = true
    },
};

/* Elements in kernel_device_frames may be enabled in specific configurations
 * only, but the ARRAY_SIZE() macro will automatically take care of this.
 * However, one corner case remains unsolved where all elements are disabled
 * and this becomes an empty array effectively. Then the C parser used in the
 * formal verification process will fail, because it follows the strict C rules
 * which do not allow empty arrays. Luckily, we have not met this case yet...
 */
#define NUM_KERNEL_DEVICE_FRAMES ARRAY_SIZE(kernel_device_frames)

/* PHYSICAL MEMORY */
static const p_region_t BOOT_RODATA avail_p_regs[] = {
    /* /memory@0 */
    {
        .start = 0x1000000,
        .end   = 0x5000000
    },
    /* /memory@0 */
    {
        .start = 0x5300000,
        .end   = 0x10000000
    },
    /* /memory@0 */
    {
        .start = 0x10200000,
        .end   = 0x80000000
    },
};

#endif /* !__ASSEMBLER__ */
